diff --git a/libquickjs-sys/embed/quickjs/libbf.c b/libquickjs-sys/embed/quickjs/libbf.c
index 2ef5104..b48e069 100644
--- a/libquickjs-sys/embed/quickjs/libbf.c
+++ b/libquickjs-sys/embed/quickjs/libbf.c
@@ -2600,11 +2600,13 @@ int bf_get_int64(int64_t *pres, const bf_t *a, int flags)
 #else
         v = a->tab[a->len - 1] >> (LIMB_BITS - a->expn);
 #endif
-        if (a->sign)
-            v = -v;
-        ret = 0;
+        if (a->sign) {
+          if (a->expn == 64 && v == (uint64_t)INT64_MAX + 1)
+            ret = 0; // not overflow, but INT64_MIN
+          v = -v;
+        }
     } else if (!(flags & BF_GET_INT_MOD)) {
-        ret = BF_ST_INVALID_OP;
+        ret = BF_ST_OVERFLOW;
         if (a->sign) {
             uint64_t v1;
             v = (uint64_t)INT64_MAX + 1;
diff --git a/libquickjs-sys/embed/quickjs/quickjs.c b/libquickjs-sys/embed/quickjs/quickjs.c
index 7da7253..984992b 100644
--- a/libquickjs-sys/embed/quickjs/quickjs.c
+++ b/libquickjs-sys/embed/quickjs/quickjs.c
@@ -11871,15 +11871,16 @@ static void JS_FreeBigInt(JSContext *ctx, bf_t *a, bf_t *buf)
 static int JS_ToBigInt64Free(JSContext *ctx, int64_t *pres, JSValue val)
 {
     bf_t a_s, *a;
+    int ret;
 
     a = JS_ToBigIntFree(ctx, &a_s, val);
     if (!a) {
         *pres = 0;
         return -1;
     }
-    bf_get_int64(pres, a, BF_GET_INT_MOD);
+    ret = bf_get_int64(pres, a, BF_GET_INT_MOD);
     JS_FreeBigInt(ctx, a, &a_s);
-    return 0;
+    return ret;
 }
 
 int JS_ToBigInt64(JSContext *ctx, int64_t *pres, JSValueConst val)
